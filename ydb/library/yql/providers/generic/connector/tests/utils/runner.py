from abc import ABC, abstractmethod
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional
import os
import json

from yt import yson
import yatest.common

from ydb.library.yql.providers.generic.connector.tests.utils.settings import Settings, GenericSettings
from ydb.library.yql.providers.generic.connector.tests.utils.schema import Schema, YsonList


@dataclass
class Result:
    data_out: Optional[YsonList]
    data_out_with_types: Optional[List]
    schema: Optional[Schema]
    stdout: str
    stderr: str
    returncode: int


class Runner(ABC):
    @abstractmethod
    def __init__(self, runner_path: Path, settings: Settings):
        pass

    @abstractmethod
    def run(
        self,
        test_name: str,
        script: str,
        generic_settings: GenericSettings,
    ) -> Result:
        """
        Runs YQL script via CLI application and stores artifacts.
        :param test_name: test name generated by request fixture (see https://stackoverflow.com/a/34732269/2361497)
        :param script: YQL script itself

        :return: Result packed with data suitable for assertion
        """
        pass

    def _make_artifact_path(self, test_name: str, artifact_name: str) -> Path:
        artifact_path = yatest.common.output_path(f'{test_name}/{artifact_name}')
        os.makedirs(os.path.dirname(artifact_path), exist_ok=True)
        return artifact_path

    def _dump_yson(self, obj, test_name: str, filename: str):
        with open(self._make_artifact_path(test_name, filename), 'wb') as f:
            f.write(yson.dumps(obj, yson_format='pretty', indent=4))

    def _dump_json(self, obj, test_name: str, filename: str):
        with open(self._make_artifact_path(test_name, filename), 'w') as f:
            f.write(json.dumps(obj, indent=4))

    def _dump_str(self, obj, test_name: str, filename: str):
        with open(self._make_artifact_path(test_name, filename), 'w') as f:
            f.write(str(obj))
